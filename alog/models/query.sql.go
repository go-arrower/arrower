// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: query.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getRecentLogs = `-- name: GetRecentLogs :many
SELECT time, user_id, log
FROM public.log
WHERE time > $1
  AND log ->> 'msg' ILIKE $3::TEXT -- cast to make Go code easier to use
  AND (CASE WHEN cardinality($4::TEXT[]) <> 0 THEN log->>'level' = ANY($4::TEXT[]) ELSE TRUE END)
  --AND (CASE WHEN @k0::TEXT <> '' THEN log->>(@k0) ILIKE @f0::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT <> '' THEN jsonb_path_exists(log, $5::JSONPATH) ELSE TRUE END) -- only use this filter, if not empty
  AND (CASE WHEN $6::TEXT <> '' THEN jsonb_path_exists(log, $6::JSONPATH) ELSE TRUE END) -- rename param with '@' as sqlc shortcut
  AND (CASE WHEN $7::TEXT <> '' THEN jsonb_path_exists(log, $7::JSONPATH) ELSE TRUE END) -- cast types, so the parameters in Go are easy to use
ORDER BY time ASC
LIMIT $2
`

type GetRecentLogsParams struct {
	Time  pgtype.Timestamptz
	Limit int32
	Msg   string
	Level []string
	F0    string
	F1    string
	F2    string
}

func (q *Queries) GetRecentLogs(ctx context.Context, arg GetRecentLogsParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, getRecentLogs,
		arg.Time,
		arg.Limit,
		arg.Msg,
		arg.Level,
		arg.F0,
		arg.F1,
		arg.F2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(&i.Time, &i.UserID, &i.Log); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logRecord = `-- name: LogRecord :exec
INSERT INTO public.log (time, user_id, log)
VALUES ($1, $2, $3)
`

type LogRecordParams struct {
	Time   pgtype.Timestamptz
	UserID uuid.NullUUID
	Log    []byte
}

func (q *Queries) LogRecord(ctx context.Context, arg LogRecordParams) error {
	_, err := q.db.Exec(ctx, logRecord, arg.Time, arg.UserID, arg.Log)
	return err
}
